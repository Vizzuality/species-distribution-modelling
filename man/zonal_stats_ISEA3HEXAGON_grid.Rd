% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/zonal_stats_ISEA3HEXAGON_grid.R
\name{zonal_stats_ISEA3HEXAGON_grid}
\alias{zonal_stats_ISEA3HEXAGON_grid}
\title{Get zonal stats binned in a hexagon grid}
\usage{
zonal_stats_ISEA3HEXAGON_grid(fun, polygon_path, raster_object,
  grid_res = 11, remove_na = T, clip = F, out_path = F)
}
\arguments{
\item{fun}{An optional function or character vector, as described in exact_extract {exactextractr}}

\item{polygon_path}{Path to geometry file compatible with sf::st_read}

\item{raster_object}{A raster::raster object}

\item{grid_res}{The zoom resolution of the ISEA-3-HEXAGON grid, see dggridR::dgconstruct}

\item{clip}{Boolean, clip by the polygon? Note this can be slow}

\item{out_path}{Path to write the grid using sf::st_write}
}
\value{
A sf object representing the ISEA-3-HEXAGON grid covering the geometry with zonal statistics as
defined by fun
}
\description{
Given a geometry (multi) polygon object, create a ISEA-3-HEXAGON grid at the given resolution
covering the geometry, apply the zonal statistics function(s) to each feature of the grid
feature collection, and return the grid with calculated properties. Optionally clipping the grid
by the geometry object, and saving to file.
}
\examples{
fun = c("mean", "mode")
polygon_path <- system.file("ext_data", "boundary-vectors", "sweden.shp", package="vspt")
# FIXME: why does it not read via system.file?
raster_path <- "/home/edward/Downloads/proj_rcp45_2020_Pinus.mugo_ensemble.grd"
#system.file("ext_data/predicted-spp-occurence-rasters/proj_rcp45_2020_Pinus.mugo_ensemble.grd", package="vspt")
raster_object <- raster::raster(raster_path, band=6, crs="+proj=longlat +datum=WGS84")
raster_object
out_path <- file.path(system.file("ext_data/predicted-spp-occurence-vectors", package="vspt"), "SWE_pinus-mugo_rcp45-2020_ensemble.geojson")
out <- zonal_stats_ISEA3HEXAGON_grid(fun,polygon_path,raster_object,grid_res = 11, remove_na = T, clip=F, out_path=out_path)
if(require(tmap)){
  tmap_mode("view")
  tm_shape(out) + tm_fill("mode", palette = sf.colors(3), alpha=0.7, colorNA=NULL)
  }else{plot(out)}
}
